**索引最左前缀原理**

**工作中用的更多的是联合索引。**

**DBA经常会建议我们少建一些单值索引，多建一些联合索引。**

**联合索引的底层存储结构长什么样？**

**依然是B+数和排好序的结构**

**怎么排好序呢？**

**按照联合索引的字段顺序逐个进行比较**

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211003104050315-354559914.png)

 **示例：下面的联合索引中，哪一条 sql 会走索引？**肯定是第一条

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211027202530505-1992297773.png)

**因为 先从 age 字段开始查找，那 就不是排好序的了。**

下面是具体示例：

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029072503877-1234497169.png)

 

 

 ![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029072523301-1957680911.png)

 

 

 **插入的顺序和查询出来的数据顺序是不一样的，这里就涉及到底层的一些原理**

**mysql是如何选择最优索引的**

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029072643767-1257238473.png)

 

 

**插入数据时 page是怎么生成的呢？** 

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029072755076-1319769168.png)

 

 

 **插入第一行数据：**

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029072836005-720151752.png)

**插入第二行数据：** 

 ![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029073127661-1178103912.png)

 **按照主键顺序插入**

**插入第三条数据：**

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029073204301-978455496.png)

 

 

 **目录项：**

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029073256816-1150491711.png)

 

 

 ![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029073503158-1684222048.png)

 

 

 　![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029073531445-343891532.png)

 

 

 ![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029073613900-91751291.png)

 

 

 **联合索引**

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029073741811-1057908104.png)

 

 

 ![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029073756902-433488141.png)

 

**根据bcd联合索引找到主键的值，然后拿着这个主键去主键索引中再找一次，我就可以定位到我要的数据**

 

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029074444509-828368733.png) 

 ![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029073613900-91751291.png)

下面的情况会不会走索引呢？

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029074857760-142300786.png)

 

 

上面的查询不会走索引。

下面的情况会不会走索引呢？

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029075214448-894741486.png)

 

 

上面的查询会走索引。

下面的情况是不会走索引的。

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029075455827-1957032354.png)

 

 

但是下面的情况又会走索引了。

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029075931499-1999707409.png)

 

 

如果不用select * 也会走索引的。

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029082450722-961904652.png)

 

 

 虽然查找出来的记录是不完整的记录，但是这些记录已经包含了b字段，所以不需要再回表查询，直接返回b字段了。

下面的情况也是可以走索引的。

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029083744638-1958211632.png)

 

 

 下面的情况会不会走索引？

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029084758488-1685243498.png)

 

 

 ![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029084954422-1605820390.png)

 

 

 

 上面的情况走索引的话不需要排序，但是要回表；如果是全表扫描的话需要排序，但不需要回表

**我们对e字段创建索引**

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029085345889-960478472.png)

 

 下面的几种sql能走索引吗，1能 0不能

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029090237057-1526043229.png)

 

 ![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029090731057-53329459.png)

 

**abc会转为数字0，所以select 结果为1**

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029090850397-1147114918.png)

 

 **如果是数字的话会转为对应的数字，那么select就为0**

 