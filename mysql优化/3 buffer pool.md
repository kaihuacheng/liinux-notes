sql语句执行流程

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029095842571-6044630.png)

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029100021676-751452959.png)

 

 ![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029100520407-329612017.png)

**不管是select还是update，都是要查询把页取出来放在内存中，mysql中有一个单独的区域用来存放页，这就是buffer pool**

**innodb architecture**

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029101051677-1967949486.png)

 

 **mysql启动的时候，会在内存中开辟一个128M的空间，这个空间就是buffer pool**

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029102235211-536322904.png)

 

 **当再取一个页放在buffer pool中的什么位置呢，buffer pool中的页的位置是不连续的，那怎么管理呢。**

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029102919868-1482105587.png)

 

 **当前buffer pool有多少个空白页，free链表就有多少个控制块。**

如果要更新数据的时候，buffer pool中的页被修改了，那么就成了脏页，脏页什么时候持久化到磁盘中呢，怎么知道哪些页是脏页呢，mysql中还有一个链表是对脏页进行管理的。

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029103726354-1414245173.png)

 

**当有一个新的页要存放到buffer pool中时，但buffer pool已经存满了，那怎么办。这就要在LRU链表中根据LRU算法进行优化。新加入的页放到这个链表的头部，这个链表的最后一个控制块就是要淘汰掉的页。** 

**有一些问题。**

**场景1：全表扫描的时候，buffer pool中的页可能会被全部替换掉。这就会导致热点数据的访问性能会降低。**

**所以mysql中是这样解决的，lru链表分为了两个区域，一个占八分之5，一个占八分之3，前面的是热数据区域，后面的是冷数据区域，新来的页放到冷数据区域的头部，冷数据区域的最后一个控制页释放掉**

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029105834418-317736610.png)

 

**那什么时候将冷数据区域中的页移动到热数据区域中来呢？冷数据区域中控制块对应的页第二次被访问到的时间大于1s时，这个页就会插入到热数据区域的头部。**

**而全表扫描时，第二次访问与第一次访问的间隔时间肯定是小于1s的，所以页是不会移动到热数据区域的。**

 

**更新的页什么时候到磁盘中呢，这就会跟事务有关系。**

![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029112921765-346811698.png)

 ![img](https://img2020.cnblogs.com/blog/597917/202110/597917-20211029113106720-1252125803.png)

 